<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Empire Builder 3D - COC Style</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Bungee&family=Inter:wght@400;700&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a1a;
            margin: 0;
            overflow: hidden;
            user-select: none;
        }

        h1, h2, h3, .font-bungee {
            font-family: 'Bungee', cursive;
        }

        #game-container {
            width: 100vw;
            height: 100vh;
        }

        .resource-bar {
            filter: drop-shadow(0 4px 6px rgba(0,0,0,0.3));
        }

        .building-card {
            transition: all 0.2s;
        }

        .building-card:hover {
            transform: translateY(-5px);
            filter: brightness(1.1);
        }

        /* Notifikasi */
        .notif {
            animation: slideIn 0.3s ease-out forwards;
        }

        @keyframes slideIn {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
    </style>
</head>
<body class="flex flex-col h-screen">

    <!-- HUD / Resources -->
    <div class="fixed top-0 left-0 right-0 p-4 flex justify-between items-start z-50 pointer-events-none">
        <div class="flex flex-col gap-2 pointer-events-auto">
            <div class="resource-bar bg-black/60 backdrop-blur-md border-2 border-yellow-500 rounded-full px-5 py-2 flex items-center gap-3">
                <span class="text-2xl">üí∞</span>
                <span id="gold-display" class="font-bungee text-yellow-400 text-xl">1000</span>
            </div>
            <div class="resource-bar bg-black/60 backdrop-blur-md border-2 border-purple-500 rounded-full px-5 py-2 flex items-center gap-3">
                <span class="text-2xl">üß™</span>
                <span id="elixir-display" class="font-bungee text-purple-400 text-xl">1000</span>
            </div>
        </div>

        <div class="pointer-events-auto flex flex-col items-end gap-2">
            <div class="bg-black/60 backdrop-blur-md border-2 border-white/30 rounded-2xl px-5 py-3 text-white text-right">
                <div class="text-xs uppercase font-bold text-gray-400 tracking-widest">Pusat Pemerintahan</div>
                <div id="th-level" class="font-bungee text-2xl text-blue-400">LVL 1</div>
            </div>
            <div class="text-white/50 text-[10px] mt-2 bg-black/40 px-2 py-1 rounded">Klik & Seret untuk Putar Kamera</div>
        </div>
    </div>

    <!-- 3D Viewport -->
    <div id="game-container"></div>

    <!-- Menu Konstruksi -->
    <div class="fixed bottom-0 left-0 right-0 bg-black/70 backdrop-blur-xl border-t-2 border-white/10 p-4 z-50">
        <div class="max-w-4xl mx-auto flex gap-4 overflow-x-auto pb-2 px-2">
            <div onclick="selectBuilding('goldMine')" class="building-card shrink-0 w-36 bg-gradient-to-b from-gray-700 to-gray-800 border-b-4 border-yellow-600 rounded-2xl p-4 flex flex-col items-center cursor-pointer shadow-xl">
                <span class="text-5xl mb-2">‚õèÔ∏è</span>
                <div class="font-bungee text-[10px] text-white text-center">Tambang Emas</div>
                <div class="text-sm text-yellow-400 mt-1 font-bold">üí∞ 250</div>
            </div>
            <div onclick="selectBuilding('elixirCollector')" class="building-card shrink-0 w-36 bg-gradient-to-b from-gray-700 to-gray-800 border-b-4 border-purple-600 rounded-2xl p-4 flex flex-col items-center cursor-pointer shadow-xl">
                <span class="text-5xl mb-2">üè∫</span>
                <div class="font-bungee text-[10px] text-white text-center">Pompa Elixir</div>
                <div class="text-sm text-purple-400 mt-1 font-bold">üß™ 250</div>
            </div>
            <div onclick="selectBuilding('barracks')" class="building-card shrink-0 w-36 bg-gradient-to-b from-gray-700 to-gray-800 border-b-4 border-red-600 rounded-2xl p-4 flex flex-col items-center cursor-pointer shadow-xl">
                <span class="text-5xl mb-2">‚öîÔ∏è</span>
                <div class="font-bungee text-[10px] text-white text-center">Barak</div>
                <div class="text-sm text-yellow-400 mt-1 font-bold">üí∞ 500</div>
            </div>
            <div onclick="selectBuilding('wall')" class="building-card shrink-0 w-36 bg-gradient-to-b from-gray-700 to-gray-800 border-b-4 border-gray-500 rounded-2xl p-4 flex flex-col items-center cursor-pointer shadow-xl">
                <span class="text-5xl mb-2">üß±</span>
                <div class="font-bungee text-[10px] text-white text-center">Benteng</div>
                <div class="text-sm text-yellow-400 mt-1 font-bold">üí∞ 50</div>
            </div>
        </div>
    </div>

    <!-- Kontrol Seleksi -->
    <div id="selection-overlay" class="fixed bottom-36 left-1/2 -translate-x-1/2 hidden flex gap-4 z-[60]">
        <button onclick="upgradeSelected()" class="bg-blue-600 hover:bg-blue-500 text-white font-bungee px-8 py-3 rounded-2xl shadow-2xl border-b-4 border-blue-800 transition-all active:translate-y-1 active:border-b-0">UPGRADE</button>
        <button onclick="destroySelected()" class="bg-red-600 hover:bg-red-500 text-white font-bungee px-8 py-3 rounded-2xl shadow-2xl border-b-4 border-red-800 transition-all active:translate-y-1 active:border-b-0">HAPUS</button>
    </div>

    <!-- Notifikasi -->
    <div id="notif-container" class="fixed top-32 left-1/2 -translate-x-1/2 flex flex-col gap-2 z-[70] pointer-events-none"></div>

    <script>
        // --- Inisialisasi Game & Three.js ---
        let scene, camera, renderer, raycaster;
        let ground, previewMesh;
        const GRID_SIZE = 2; // Ukuran satu kotak grid dalam unit Three.js
        const WORLD_SIZE = 20; // 20x20 grid

        let resources = { gold: 1000, elixir: 1000 };
        let buildings = [];
        let selectedId = null;
        let placementMode = null;

        // Mouse & Kamera State
        let mouse = new THREE.Vector2();
        let isMouseDown = false;
        let startRotation = { y: 0.7, x: -0.6 };
        let currentRotation = { y: 0.7, x: -0.6 };
        let startMouse = { x: 0, y: 0 };

        const BUILDING_TYPES = {
            townHall: { name: 'Balai Kota', color: 0x8b4513, size: 3, icon: 'üè∞', cost: 0, costType: 'gold', income: { gold: 5, elixir: 5 } },
            goldMine: { name: 'Tambang Emas', color: 0xffd700, size: 2, icon: '‚õèÔ∏è', cost: 250, costType: 'gold', income: { gold: 15 } },
            elixirCollector: { name: 'Pompa Elixir', color: 0x9932cc, size: 2, icon: 'üè∫', cost: 250, costType: 'elixir', income: { elixir: 15 } },
            barracks: { name: 'Barak', color: 0xff4500, size: 2, icon: '‚öîÔ∏è', cost: 500, costType: 'gold', income: {} },
            wall: { name: 'Tembok', color: 0x808080, size: 1, icon: 'üß±', cost: 50, costType: 'gold', income: {} }
        };

        window.onload = function() {
            initScene();
            initGame();
            animate();
        };

        function initScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x334d2a); // Hijau Rumput Tua

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            updateCameraPosition();

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('game-container').appendChild(renderer.domElement);

            raycaster = new THREE.Raycaster();

            // Pencahayaan
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(50, 100, 50);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            // Lantai / Grid
            const groundGeo = new THREE.PlaneGeometry(WORLD_SIZE * GRID_SIZE, WORLD_SIZE * GRID_SIZE);
            const groundMat = new THREE.MeshPhongMaterial({ color: 0x567d46 });
            ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            const gridHelper = new THREE.GridHelper(WORLD_SIZE * GRID_SIZE, WORLD_SIZE, 0xffffff, 0x000000);
            gridHelper.position.y = 0.05;
            gridHelper.material.opacity = 0.1;
            gridHelper.material.transparent = true;
            scene.add(gridHelper);

            // Preview Placement
            const previewGeo = new THREE.BoxGeometry(1, 1, 1);
            const previewMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.4 });
            previewMesh = new THREE.Mesh(previewGeo, previewMat);
            previewMesh.visible = false;
            scene.add(previewMesh);

            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        }

        function initGame() {
            // Bangunan awal: Town Hall
            createBuilding('townHall', 0, 0, 1);
            setInterval(passiveIncome, 1000);
        }

        function passiveIncome() {
            buildings.forEach(b => {
                const type = BUILDING_TYPES[b.type];
                if (type.income) {
                    if (type.income.gold) resources.gold += type.income.gold * b.level;
                    if (type.income.elixir) resources.elixir += type.income.elixir * b.level;
                }
            });
            updateUI();
        }

        function createBuilding(typeKey, gridX, gridY, level = 1) {
            const type = BUILDING_TYPES[typeKey];
            const group = new THREE.Group();

            // Mesh Utama (Bangunan)
            const boxGeo = new THREE.BoxGeometry(type.size * GRID_SIZE - 0.2, (type.size * 0.8) * GRID_SIZE, type.size * GRID_SIZE - 0.2);
            const boxMat = new THREE.MeshPhongMaterial({ color: type.color });
            const mesh = new THREE.Mesh(boxGeo, boxMat);
            mesh.position.y = (type.size * 0.4) * GRID_SIZE;
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            group.add(mesh);

            // Atap (Sederhana)
            const roofGeo = new THREE.BoxGeometry(type.size * GRID_SIZE + 0.1, 0.5, type.size * GRID_SIZE + 0.1);
            const roofMat = new THREE.MeshPhongMaterial({ color: 0x444444 });
            const roof = new THREE.Mesh(roofGeo, roofMat);
            roof.position.y = (type.size * 0.8) * GRID_SIZE + 0.25;
            group.add(roof);

            // Posisi di Grid
            const worldX = (gridX * GRID_SIZE) - (WORLD_SIZE * GRID_SIZE / 2) + (type.size * GRID_SIZE / 2);
            const worldZ = (gridY * GRID_SIZE) - (WORLD_SIZE * GRID_SIZE / 2) + (type.size * GRID_SIZE / 2);
            group.position.set(worldX, 0, worldZ);

            scene.add(group);

            const bData = {
                id: Date.now() + Math.random(),
                type: typeKey,
                gridX, gridY,
                level,
                mesh: group
            };
            buildings.push(bData);
            return bData;
        }

        function animate() {
            requestAnimationFrame(animate);
            
            if (placementMode) {
                updatePlacementPreview();
            }

            renderer.render(scene, camera);
        }

        // --- Kontrol & Interaksi ---

        function onMouseDown(e) {
            if (e.target.closest('button') || e.target.closest('.building-card')) return;
            
            isMouseDown = true;
            startMouse.x = e.clientX;
            startMouse.y = e.clientY;
            startRotation.y = currentRotation.y;
            startRotation.x = currentRotation.x;
        }

        function onMouseMove(e) {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

            if (isMouseDown) {
                const deltaX = e.clientX - startMouse.x;
                const deltaY = e.clientY - startMouse.y;
                currentRotation.y = startRotation.y + deltaX * 0.005;
                currentRotation.x = Math.max(-1.2, Math.min(-0.2, startRotation.x + deltaY * 0.005));
                updateCameraPosition();
            }
        }

        function onMouseUp(e) {
            if (isMouseDown && Math.abs(e.clientX - startMouse.x) < 5) {
                handleInteraction();
            }
            isMouseDown = false;
        }

        function updateCameraPosition() {
            const distance = 45;
            camera.position.x = distance * Math.sin(currentRotation.y) * Math.cos(currentRotation.x);
            camera.position.z = distance * Math.cos(currentRotation.y) * Math.cos(currentRotation.x);
            camera.position.y = -distance * Math.sin(currentRotation.x);
            camera.lookAt(0, 0, 0);
        }

        function updatePlacementPreview() {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(ground);

            if (intersects.length > 0) {
                const pt = intersects[0].point;
                const type = BUILDING_TYPES[placementMode];
                
                // Konversi koordinat dunia ke koordinat grid
                let gx = Math.floor((pt.x + (WORLD_SIZE * GRID_SIZE / 2)) / GRID_SIZE);
                let gy = Math.floor((pt.z + (WORLD_SIZE * GRID_SIZE / 2)) / GRID_SIZE);

                // Snap ke grid
                const worldX = (gx * GRID_SIZE) - (WORLD_SIZE * GRID_SIZE / 2) + (type.size * GRID_SIZE / 2);
                const worldZ = (gy * GRID_SIZE) - (WORLD_SIZE * GRID_SIZE / 2) + (type.size * GRID_SIZE / 2);

                previewMesh.scale.set(type.size * GRID_SIZE, 0.5, type.size * GRID_SIZE);
                previewMesh.position.set(worldX, 0.25, worldZ);
                previewMesh.visible = true;

                const valid = canPlace(gx, gy, type.size);
                previewMesh.material.color.setHex(valid ? 0x00ff00 : 0xff0000);
            } else {
                previewMesh.visible = false;
            }
        }

        function handleInteraction() {
            raycaster.setFromCamera(mouse, camera);
            
            if (placementMode) {
                const intersects = raycaster.intersectObject(ground);
                if (intersects.length > 0) {
                    const pt = intersects[0].point;
                    let gx = Math.floor((pt.x + (WORLD_SIZE * GRID_SIZE / 2)) / GRID_SIZE);
                    let gy = Math.floor((pt.z + (WORLD_SIZE * GRID_SIZE / 2)) / GRID_SIZE);
                    placeBuilding(gx, gy);
                }
            } else {
                const intersects = raycaster.intersectObjects(buildings.map(b => b.mesh), true);
                if (intersects.length > 0) {
                    let clickedGroup = intersects[0].object;
                    while (clickedGroup.parent && clickedGroup.parent.type !== "Scene") {
                        clickedGroup = clickedGroup.parent;
                    }
                    const b = buildings.find(b => b.mesh === clickedGroup);
                    if (b) selectBuildingInstance(b);
                } else {
                    deselect();
                }
            }
        }

        // --- Logika Game ---

        function canPlace(gx, gy, size) {
            if (gx < 0 || gy < 0 || gx + size > WORLD_SIZE || gy + size > WORLD_SIZE) return false;
            return !buildings.some(b => {
                const bSize = BUILDING_TYPES[b.type].size;
                return gx < b.gridX + bSize && gx + size > b.gridX &&
                       gy < b.gridY + bSize && gy + size > b.gridY;
            });
        }

        function selectBuilding(type) {
            if (resources[BUILDING_TYPES[type].costType] < BUILDING_TYPES[type].cost) {
                showNotif("Sumber daya tidak cukup!", "red");
                return;
            }
            placementMode = type;
            deselect();
            showNotif(`Letakkan ${BUILDING_TYPES[type].name}`, "blue");
        }

        function placeBuilding(gx, gy) {
            const type = BUILDING_TYPES[placementMode];
            if (canPlace(gx, gy, type.size)) {
                resources[type.costType] -= type.cost;
                createBuilding(placementMode, gx, gy);
                placementMode = null;
                previewMesh.visible = false;
                updateUI();
                showNotif(`${type.name} Berhasil Dibangun`, "green");
            } else {
                showNotif("Area Terhalang!", "red");
            }
        }

        function selectBuildingInstance(b) {
            selectedId = b.id;
            buildings.forEach(item => {
                item.mesh.children[0].material.emissive.setHex(item.id === selectedId ? 0x333333 : 0x000000);
            });
            document.getElementById('selection-overlay').classList.remove('hidden');
        }

        function deselect() {
            selectedId = null;
            buildings.forEach(item => item.mesh.children[0].material.emissive.setHex(0x000000));
            document.getElementById('selection-overlay').classList.add('hidden');
        }

        function upgradeSelected() {
            const b = buildings.find(t => t.id === selectedId);
            if (!b) return;

            const cost = b.level * 500;
            if (resources.gold >= cost) {
                resources.gold -= cost;
                b.level++;
                
                // Update Visual (Sisik / Tinggi)
                b.mesh.scale.y += 0.2;
                b.mesh.position.y += 0.1;
                
                if (b.type === 'townHall') {
                    document.getElementById('th-level').innerText = `LVL ${b.level}`;
                }
                showNotif("Upgrade Berhasil!", "blue");
                updateUI();
            } else {
                showNotif(`Butuh üí∞ ${cost} Emas`, "red");
            }
        }

        function destroySelected() {
            const index = buildings.findIndex(b => b.id === selectedId);
            if (index === -1) return;
            
            const b = buildings[index];
            if (b.type === 'townHall') {
                showNotif("Tidak bisa menghapus Pusat Pemerintahan!", "orange");
                return;
            }

            scene.remove(b.mesh);
            buildings.splice(index, 1);
            deselect();
            showNotif("Bangunan Dihancurkan", "gray");
        }

        // --- Utilitas UI ---

        function updateUI() {
            document.getElementById('gold-display').innerText = Math.floor(resources.gold);
            document.getElementById('elixir-display').innerText = Math.floor(resources.elixir);
        }

        function showNotif(msg, color) {
            const div = document.createElement('div');
            const colors = {
                red: 'bg-red-600', green: 'bg-green-600', 
                blue: 'bg-blue-600', orange: 'bg-orange-600', gray: 'bg-gray-700'
            };
            div.className = `notif ${colors[color] || 'bg-black'} text-white font-bold px-8 py-3 rounded-2xl shadow-2xl`;
            div.innerText = msg;
            
            const container = document.getElementById('notif-container');
            container.appendChild(div);

            setTimeout(() => {
                div.style.opacity = '0';
                div.style.transform = 'translateY(-20px)';
                setTimeout(() => div.remove(), 500);
            }, 3000);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

    </script>
</body>
</html>
