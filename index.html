<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Empire Builder 3D - COC Style</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Bungee&family=Inter:wght@400;700&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a1a;
            margin: 0;
            overflow: hidden;
            user-select: none;
        }

        h1, h2, h3, .font-bungee {
            font-family: 'Bungee', cursive;
        }

        #game-container {
            width: 100vw;
            height: 100vh;
        }

        .resource-bar {
            filter: drop-shadow(0 4px 6px rgba(0,0,0,0.3));
        }

        .building-card {
            transition: all 0.2s;
        }

        .building-card:hover {
            transform: translateY(-5px);
            filter: brightness(1.1);
        }

        .notif {
            animation: slideIn 0.3s ease-out forwards;
        }

        @keyframes slideIn {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
    </style>
</head>
<body class="flex flex-col h-screen">

    <!-- HUD / Resources -->
    <div class="fixed top-0 left-0 right-0 p-4 flex justify-between items-start z-50 pointer-events-none">
        <div class="flex flex-col gap-2 pointer-events-auto">
            <div class="resource-bar bg-black/60 backdrop-blur-md border-2 border-yellow-500 rounded-full px-5 py-2 flex items-center gap-3">
                <span class="text-2xl">üí∞</span>
                <span id="gold-display" class="font-bungee text-yellow-400 text-xl">1000</span>
            </div>
            <div class="resource-bar bg-black/60 backdrop-blur-md border-2 border-purple-500 rounded-full px-5 py-2 flex items-center gap-3">
                <span class="text-2xl">üß™</span>
                <span id="elixir-display" class="font-bungee text-purple-400 text-xl">1000</span>
            </div>
        </div>

        <div class="pointer-events-auto flex flex-col items-end gap-2">
            <div class="bg-black/60 backdrop-blur-md border-2 border-white/30 rounded-2xl px-5 py-3 text-white text-right">
                <div class="text-xs uppercase font-bold text-gray-400 tracking-widest">Pusat Pemerintahan</div>
                <div id="th-level" class="font-bungee text-2xl text-blue-400">LVL 1</div>
            </div>
            <div class="text-white/50 text-[10px] mt-2 bg-black/40 px-2 py-1 rounded">Klik & Seret untuk Putar Kamera</div>
        </div>
    </div>

    <!-- 3D Viewport -->
    <div id="game-container"></div>

    <!-- Menu Konstruksi -->
    <div class="fixed bottom-0 left-0 right-0 bg-black/70 backdrop-blur-xl border-t-2 border-white/10 p-4 z-50">
        <div class="max-w-4xl mx-auto flex gap-4 overflow-x-auto pb-2 px-2">
            <div onclick="selectBuilding('goldMine')" class="building-card shrink-0 w-36 bg-gradient-to-b from-gray-700 to-gray-800 border-b-4 border-yellow-600 rounded-2xl p-4 flex flex-col items-center cursor-pointer shadow-xl">
                <span class="text-5xl mb-2">‚õèÔ∏è</span>
                <div class="font-bungee text-[10px] text-white text-center">Tambang Emas</div>
                <div class="text-sm text-yellow-400 mt-1 font-bold">üí∞ 250</div>
            </div>
            <div onclick="selectBuilding('elixirCollector')" class="building-card shrink-0 w-36 bg-gradient-to-b from-gray-700 to-gray-800 border-b-4 border-purple-600 rounded-2xl p-4 flex flex-col items-center cursor-pointer shadow-xl">
                <span class="text-5xl mb-2">üè∫</span>
                <div class="font-bungee text-[10px] text-white text-center">Pompa Elixir</div>
                <div class="text-sm text-purple-400 mt-1 font-bold">üß™ 250</div>
            </div>
            <div onclick="selectBuilding('barracks')" class="building-card shrink-0 w-36 bg-gradient-to-b from-gray-700 to-gray-800 border-b-4 border-red-600 rounded-2xl p-4 flex flex-col items-center cursor-pointer shadow-xl">
                <span class="text-5xl mb-2">‚öîÔ∏è</span>
                <div class="font-bungee text-[10px] text-white text-center">Barak</div>
                <div class="text-sm text-yellow-400 mt-1 font-bold">üí∞ 500</div>
            </div>
            <div onclick="selectBuilding('wall')" class="building-card shrink-0 w-36 bg-gradient-to-b from-gray-700 to-gray-800 border-b-4 border-gray-500 rounded-2xl p-4 flex flex-col items-center cursor-pointer shadow-xl">
                <span class="text-5xl mb-2">üß±</span>
                <div class="font-bungee text-[10px] text-white text-center">Benteng</div>
                <div class="text-sm text-yellow-400 mt-1 font-bold">üí∞ 50</div>
            </div>
        </div>
    </div>

    <!-- Kontrol Seleksi -->
    <div id="selection-overlay" class="fixed bottom-36 left-1/2 -translate-x-1/2 hidden flex gap-4 z-[60]">
        <button onclick="upgradeSelected()" class="bg-blue-600 hover:bg-blue-500 text-white font-bungee px-8 py-3 rounded-2xl shadow-2xl border-b-4 border-blue-800 transition-all active:translate-y-1 active:border-b-0">UPGRADE</button>
        <button onclick="destroySelected()" class="bg-red-600 hover:bg-red-500 text-white font-bungee px-8 py-3 rounded-2xl shadow-2xl border-b-4 border-red-800 transition-all active:translate-y-1 active:border-b-0">HAPUS</button>
    </div>

    <!-- Notifikasi -->
    <div id="notif-container" class="fixed top-32 left-1/2 -translate-x-1/2 flex flex-col gap-2 z-[70] pointer-events-none"></div>

    <script>
        let scene, camera, renderer, raycaster;
        let ground, previewMesh;
        const GRID_SIZE = 2;
        const WORLD_SIZE = 20;

        let resources = { gold: 1000, elixir: 1000 };
        let buildings = [];
        let selectedId = null;
        let placementMode = null;

        let mouse = new THREE.Vector2();
        let isMouseDown = false;
        let startRotation = { y: 0.7, x: -0.6 };
        let currentRotation = { y: 0.7, x: -0.6 };
        let startMouse = { x: 0, y: 0 };

        const BUILDING_TYPES = {
            townHall: { name: 'Balai Kota', color: 0x8b4513, size: 3, cost: 0, costType: 'gold', income: { gold: 5, elixir: 5 } },
            goldMine: { name: 'Tambang Emas', color: 0xffd700, size: 2, cost: 250, costType: 'gold', income: { gold: 15 } },
            elixirCollector: { name: 'Pompa Elixir', color: 0x9932cc, size: 2, cost: 250, costType: 'elixir', income: { elixir: 15 } },
            barracks: { name: 'Barak', color: 0xff4500, size: 2, cost: 500, costType: 'gold', income: {} },
            wall: { name: 'Tembok', color: 0xaaaaaa, size: 1, cost: 50, costType: 'gold', income: {} }
        };

        window.onload = function() {
            initScene();
            initGame();
            animate();
        };

        function initScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x3d5e32); 

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            updateCameraPosition();

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('game-container').appendChild(renderer.domElement);

            raycaster = new THREE.Raycaster();

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
            dirLight.position.set(40, 100, 20);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 4096;
            dirLight.shadow.mapSize.height = 4096;
            dirLight.shadow.camera.left = -50;
            dirLight.shadow.camera.right = 50;
            dirLight.shadow.camera.top = 50;
            dirLight.shadow.camera.bottom = -50;
            scene.add(dirLight);

            const groundGeo = new THREE.PlaneGeometry(WORLD_SIZE * GRID_SIZE, WORLD_SIZE * GRID_SIZE);
            const groundMat = new THREE.MeshPhongMaterial({ color: 0x567d46 });
            ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            const gridHelper = new THREE.GridHelper(WORLD_SIZE * GRID_SIZE, WORLD_SIZE, 0xffffff, 0x000000);
            gridHelper.position.y = 0.05;
            gridHelper.material.opacity = 0.08;
            gridHelper.material.transparent = true;
            scene.add(gridHelper);

            const previewGeo = new THREE.BoxGeometry(1, 1, 1);
            const previewMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.3 });
            previewMesh = new THREE.Mesh(previewGeo, previewMat);
            previewMesh.visible = false;
            scene.add(previewMesh);

            window.addEventListener('resize', onWindowResize);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        }

        function initGame() {
            createBuilding('townHall', 0, 0, 1);
            setInterval(passiveIncome, 1000);
        }

        function passiveIncome() {
            buildings.forEach(b => {
                const type = BUILDING_TYPES[b.type];
                if (type.income) {
                    if (type.income.gold) resources.gold += type.income.gold * b.level;
                    if (type.income.elixir) resources.elixir += type.income.elixir * b.level;
                }
            });
            updateUI();
        }

        // Helper untuk membuat box dengan shadow
        function createBox(w, h, d, color, px, py, pz) {
            const mesh = new THREE.Mesh(
                new THREE.BoxGeometry(w, h, d),
                new THREE.MeshPhongMaterial({ color })
            );
            mesh.position.set(px, py, pz);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            return mesh;
        }

        function createBuilding(typeKey, gridX, gridY, level = 1) {
            const type = BUILDING_TYPES[typeKey];
            const group = new THREE.Group();
            const pSize = type.size * GRID_SIZE;

            switch(typeKey) {
                case 'townHall':
                    // Basis kayu/batu
                    group.add(createBox(pSize * 0.9, pSize * 0.4, pSize * 0.9, 0x7a5c3e, 0, pSize * 0.2, 0));
                    // Lantai dua
                    group.add(createBox(pSize * 0.7, pSize * 0.3, pSize * 0.7, 0x8b6d4d, 0, pSize * 0.5, 0));
                    // Pintu
                    group.add(createBox(pSize * 0.15, pSize * 0.25, 0.1, 0x3d2b1f, 0, pSize * 0.125, pSize * 0.45));
                    // Atap Slanted (Piramida)
                    const roofGeo = new THREE.CylinderGeometry(0, pSize * 0.6, pSize * 0.4, 4);
                    const roof = new THREE.Mesh(roofGeo, new THREE.MeshPhongMaterial({ color: 0x8b0000 }));
                    roof.position.y = pSize * 0.85;
                    roof.rotation.y = Math.PI / 4;
                    roof.castShadow = true;
                    group.add(roof);
                    // Bendera kecil
                    const pole = createBox(0.05, 0.8, 0.05, 0xdddddd, 0, pSize * 1.2, 0);
                    group.add(pole);
                    const flag = createBox(0.4, 0.2, 0.02, 0xffff00, 0.2, pSize * 1.5, 0);
                    group.add(flag);
                    break;

                case 'goldMine':
                    // Struktur Kayu
                    group.add(createBox(pSize * 0.8, 0.2, pSize * 0.8, 0x4d332d, 0, 0.1, 0));
                    group.add(createBox(0.2, pSize * 0.6, 0.2, 0x5d4037, -pSize * 0.3, pSize * 0.3, -pSize * 0.3));
                    group.add(createBox(0.2, pSize * 0.6, 0.2, 0x5d4037, pSize * 0.3, pSize * 0.3, -pSize * 0.3));
                    // Katrol
                    const wheel = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.3, 0.3, 0.15, 12),
                        new THREE.MeshPhongMaterial({ color: 0x333333 })
                    );
                    wheel.rotation.z = Math.PI / 2;
                    wheel.position.set(0, pSize * 0.5, -pSize * 0.3);
                    group.add(wheel);
                    // Keranjang Emas
                    const cart = createBox(0.6, 0.4, 0.6, 0x222222, 0, 0.3, 0.2);
                    group.add(cart);
                    const goldInCart = new THREE.Mesh(
                        new THREE.SphereGeometry(0.25, 6, 6),
                        new THREE.MeshPhongMaterial({ color: 0xffd700, emissive: 0x554400 })
                    );
                    goldInCart.position.set(0, 0.5, 0.2);
                    group.add(goldInCart);
                    group.userData.anim = (t) => { wheel.rotation.y += 0.05; goldInCart.rotation.y += 0.02; };
                    break;

                case 'elixirCollector':
                    // Alas Logam
                    const base = new THREE.Mesh(new THREE.CylinderGeometry(pSize * 0.4, pSize * 0.45, 0.4, 16), new THREE.MeshPhongMaterial({ color: 0x666666 }));
                    base.position.y = 0.2;
                    group.add(base);
                    // Tabung Kaca
                    const glass = new THREE.Mesh(
                        new THREE.CylinderGeometry(pSize * 0.35, pSize * 0.35, pSize * 0.7, 16),
                        new THREE.MeshPhongMaterial({ color: 0x9932cc, transparent: true, opacity: 0.6, emissive: 0x330033 })
                    );
                    glass.position.y = pSize * 0.35 + 0.4;
                    group.add(glass);
                    // Pipa-pipa
                    const pipe = new THREE.Mesh(new THREE.TorusGeometry(0.4, 0.1, 8, 16, Math.PI), new THREE.MeshPhongMaterial({ color: 0xaa8800 }));
                    pipe.position.set(pSize * 0.3, 0.5, 0);
                    pipe.rotation.z = -Math.PI / 2;
                    group.add(pipe);
                    // Animasi denyut elixir
                    group.userData.anim = (t) => { glass.scale.set(1 + Math.sin(t*3)*0.02, 1, 1 + Math.sin(t*3)*0.02); };
                    break;

                case 'barracks':
                    // Tenda Barak
                    const tentGeo = new THREE.CylinderGeometry(0.1, pSize * 0.5, pSize * 0.7, 4);
                    const tent = new THREE.Mesh(tentGeo, new THREE.MeshPhongMaterial({ color: 0xaa2222 }));
                    tent.position.y = pSize * 0.35;
                    tent.rotation.y = Math.PI / 4;
                    group.add(tent);
                    // Pintu Tenda
                    const tDoor = createBox(0.4, 0.6, 0.1, 0x221111, 0, 0.3, pSize * 0.35);
                    group.add(tDoor);
                    // Pedang nancap di batu
                    const stone = new THREE.Mesh(new THREE.IcosahedronGeometry(0.3, 0), new THREE.MeshPhongMaterial({ color: 0x777777 }));
                    stone.position.set(pSize * 0.35, 0.2, pSize * 0.35);
                    group.add(stone);
                    const sword = createBox(0.05, 0.7, 0.05, 0xcccccc, pSize * 0.35, 0.6, pSize * 0.35);
                    sword.rotation.z = 0.2;
                    group.add(sword);
                    break;

                case 'wall':
                    // Pilar Utama
                    group.add(createBox(pSize - 0.2, pSize * 0.8, pSize - 0.2, 0x888888, 0, pSize * 0.4, 0));
                    // Detail gerigi atas
                    for(let i=0; i<4; i++) {
                        const tooth = createBox(0.4, 0.3, 0.4, 0x666666, 
                            (i<2 ? -0.4 : 0.4), pSize * 0.8 + 0.15, (i%2==0 ? -0.4 : 0.4));
                        group.add(tooth);
                    }
                    break;
            }

            const worldX = (gridX * GRID_SIZE) - (WORLD_SIZE * GRID_SIZE / 2) + (pSize / 2);
            const worldZ = (gridY * GRID_SIZE) - (WORLD_SIZE * GRID_SIZE / 2) + (pSize / 2);
            group.position.set(worldX, 0, worldZ);
            scene.add(group);

            const bData = { id: Date.now() + Math.random(), type: typeKey, gridX, gridY, level, mesh: group };
            buildings.push(bData);
            return bData;
        }

        function animate(time) {
            requestAnimationFrame(animate);
            const t = time * 0.001;
            
            buildings.forEach(b => {
                if(b.mesh.userData.anim) b.mesh.userData.anim(t);
            });

            if (placementMode) updatePlacementPreview();
            renderer.render(scene, camera);
        }

        function onMouseDown(e) {
            if (e.target.closest('button') || e.target.closest('.building-card')) return;
            isMouseDown = true;
            startMouse.x = e.clientX;
            startMouse.y = e.clientY;
            startRotation.y = currentRotation.y;
            startRotation.x = currentRotation.x;
        }

        function onMouseMove(e) {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            if (isMouseDown) {
                const deltaX = e.clientX - startMouse.x;
                const deltaY = e.clientY - startMouse.y;
                currentRotation.y = startRotation.y + deltaX * 0.005;
                currentRotation.x = Math.max(-1.2, Math.min(-0.2, startRotation.x + deltaY * 0.005));
                updateCameraPosition();
            }
        }

        function onMouseUp(e) {
            if (isMouseDown && Math.abs(e.clientX - startMouse.x) < 5) handleInteraction();
            isMouseDown = false;
        }

        function updateCameraPosition() {
            const distance = 45;
            camera.position.x = distance * Math.sin(currentRotation.y) * Math.cos(currentRotation.x);
            camera.position.z = distance * Math.cos(currentRotation.y) * Math.cos(currentRotation.x);
            camera.position.y = -distance * Math.sin(currentRotation.x);
            camera.lookAt(0, 0, 0);
        }

        function updatePlacementPreview() {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(ground);
            if (intersects.length > 0) {
                const pt = intersects[0].point;
                const type = BUILDING_TYPES[placementMode];
                let gx = Math.floor((pt.x + (WORLD_SIZE * GRID_SIZE / 2)) / GRID_SIZE);
                let gy = Math.floor((pt.z + (WORLD_SIZE * GRID_SIZE / 2)) / GRID_SIZE);
                const worldX = (gx * GRID_SIZE) - (WORLD_SIZE * GRID_SIZE / 2) + (type.size * GRID_SIZE / 2);
                const worldZ = (gy * GRID_SIZE) - (WORLD_SIZE * GRID_SIZE / 2) + (type.size * GRID_SIZE / 2);
                previewMesh.scale.set(type.size * GRID_SIZE, 0.5, type.size * GRID_SIZE);
                previewMesh.position.set(worldX, 0.25, worldZ);
                previewMesh.visible = true;
                const valid = canPlace(gx, gy, type.size);
                previewMesh.material.color.setHex(valid ? 0x00ff00 : 0xff0000);
            } else { previewMesh.visible = false; }
        }

        function handleInteraction() {
            raycaster.setFromCamera(mouse, camera);
            if (placementMode) {
                const intersects = raycaster.intersectObject(ground);
                if (intersects.length > 0) {
                    const pt = intersects[0].point;
                    let gx = Math.floor((pt.x + (WORLD_SIZE * GRID_SIZE / 2)) / GRID_SIZE);
                    let gy = Math.floor((pt.z + (WORLD_SIZE * GRID_SIZE / 2)) / GRID_SIZE);
                    placeBuilding(gx, gy);
                }
            } else {
                const intersects = raycaster.intersectObjects(buildings.map(b => b.mesh), true);
                if (intersects.length > 0) {
                    let clickedGroup = intersects[0].object;
                    while (clickedGroup.parent && clickedGroup.parent.type !== "Scene") clickedGroup = clickedGroup.parent;
                    const b = buildings.find(b => b.mesh === clickedGroup);
                    if (b) selectBuildingInstance(b);
                } else { deselect(); }
            }
        }

        function canPlace(gx, gy, size) {
            if (gx < 0 || gy < 0 || gx + size > WORLD_SIZE || gy + size > WORLD_SIZE) return false;
            return !buildings.some(b => {
                const bSize = BUILDING_TYPES[b.type].size;
                return gx < b.gridX + bSize && gx + size > b.gridX && gy < b.gridY + bSize && gy + size > b.gridY;
            });
        }

        function selectBuilding(type) {
            if (resources[BUILDING_TYPES[type].costType] < BUILDING_TYPES[type].cost) {
                showNotif("Sumber daya tidak cukup!", "red");
                return;
            }
            placementMode = type;
            deselect();
            showNotif(`Letakkan ${BUILDING_TYPES[type].name}`, "blue");
        }

        function placeBuilding(gx, gy) {
            const type = BUILDING_TYPES[placementMode];
            if (canPlace(gx, gy, type.size)) {
                resources[type.costType] -= type.cost;
                createBuilding(placementMode, gx, gy);
                placementMode = null;
                previewMesh.visible = false;
                updateUI();
                showNotif(`${type.name} Berhasil Dibangun`, "green");
            } else { showNotif("Area Terhalang!", "red"); }
        }

        function selectBuildingInstance(b) {
            selectedId = b.id;
            buildings.forEach(item => {
                item.mesh.traverse(child => {
                    if(child.material && child.material.emissive) child.material.emissive.setHex(item.id === selectedId ? 0x222222 : 0x000000);
                });
            });
            document.getElementById('selection-overlay').classList.remove('hidden');
        }

        function deselect() {
            selectedId = null;
            buildings.forEach(item => {
                item.mesh.traverse(child => {
                    if(child.material && child.material.emissive) child.material.emissive.setHex(0x000000);
                });
            });
            document.getElementById('selection-overlay').classList.add('hidden');
        }

        function upgradeSelected() {
            const b = buildings.find(t => t.id === selectedId);
            if (!b) return;
            const cost = b.level * 500;
            if (resources.gold >= cost) {
                resources.gold -= cost;
                b.level++;
                b.mesh.scale.y += 0.05;
                b.mesh.position.y += 0.05;
                if (b.type === 'townHall') document.getElementById('th-level').innerText = `LVL ${b.level}`;
                showNotif("Upgrade Berhasil!", "blue");
                updateUI();
            } else { showNotif(`Butuh üí∞ ${cost} Emas`, "red"); }
        }

        function destroySelected() {
            const index = buildings.findIndex(b => b.id === selectedId);
            if (index === -1) return;
            const b = buildings[index];
            if (b.type === 'townHall') {
                showNotif("Pusat Pemerintahan tidak bisa dihapus!", "orange");
                return;
            }
            scene.remove(b.mesh);
            buildings.splice(index, 1);
            deselect();
            showNotif("Bangunan Dihancurkan", "gray");
        }

        function updateUI() {
            document.getElementById('gold-display').innerText = Math.floor(resources.gold);
            document.getElementById('elixir-display').innerText = Math.floor(resources.elixir);
        }

        function showNotif(msg, color) {
            const div = document.createElement('div');
            const colors = { red: 'bg-red-600', green: 'bg-green-600', blue: 'bg-blue-600', orange: 'bg-orange-600', gray: 'bg-gray-700' };
            div.className = `notif ${colors[color] || 'bg-black'} text-white font-bold px-8 py-3 rounded-2xl shadow-2xl`;
            div.innerText = msg;
            const container = document.getElementById('notif-container');
            container.appendChild(div);
            setTimeout(() => {
                div.style.opacity = '0';
                div.style.transform = 'translateY(-20px)';
                setTimeout(() => div.remove(), 500);
            }, 3000);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>
